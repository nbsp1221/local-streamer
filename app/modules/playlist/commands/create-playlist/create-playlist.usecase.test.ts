import { beforeEach, describe, expect, it, vi } from 'vitest';
import { InternalError, ValidationError } from '~/lib/errors';
import { Result } from '~/lib/result';
import type { Playlist } from '../../domain/playlist.types';
import {
  DuplicatePlaylistNameError,
  InvalidPlaylistDataError,
  InvalidPlaylistTypeError,
  InvalidSeriesMetadataError,
} from '../../domain/playlist.errors';
import type {
  CreatePlaylistDependencies,
  CreatePlaylistUseCaseRequest,
} from './create-playlist.types';
import { CreatePlaylistUseCase } from './create-playlist.usecase';

describe('CreatePlaylistUseCase', () => {
  let useCase: CreatePlaylistUseCase;
  let mockDependencies: CreatePlaylistDependencies;
  let mockPlaylistRepository: any;
  let mockUserRepository: any;
  let mockLogger: any;

  const userId = 'user-123';
  const validRequest: CreatePlaylistUseCaseRequest = {
    name: 'My Test Playlist',
    description: 'A test playlist',
    type: 'user_created',
    isPublic: false,
    userId,
  };

  const mockPlaylist: Playlist = {
    id: 'playlist-456',
    name: 'My Test Playlist',
    description: 'A test playlist',
    type: 'user_created',
    videoIds: [],
    ownerId: userId,
    isPublic: false,
    createdAt: new Date('2025-01-15T10:00:00Z'),
    updatedAt: new Date('2025-01-15T10:00:00Z'),
  };

  beforeEach(() => {
    // Create mock playlist repository
    mockPlaylistRepository = {
      create: vi.fn(),
      nameExistsForUser: vi.fn(),
    };

    // Create mock user repository
    mockUserRepository = {
      exists: vi.fn(),
    };

    // Create mock logger
    mockLogger = {
      info: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
    };

    // Setup dependencies
    mockDependencies = {
      playlistRepository: mockPlaylistRepository,
      userRepository: mockUserRepository,
      logger: mockLogger,
    };

    useCase = new CreatePlaylistUseCase(mockDependencies);
  });

  describe('Successful playlist creation', () => {
    it('should create a user playlist successfully', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);
      mockPlaylistRepository.create.mockResolvedValue(mockPlaylist);

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual({
          playlistId: 'playlist-456',
          message: 'Playlist "My Test Playlist" created successfully',
          autoGeneratedThumbnail: false,
          suggestedMetadata: undefined,
        });
      }

      expect(mockUserRepository.exists).toHaveBeenCalledWith(userId);
      expect(mockPlaylistRepository.nameExistsForUser).toHaveBeenCalledWith('My Test Playlist', userId);
      expect(mockPlaylistRepository.create).toHaveBeenCalledWith({
        name: 'My Test Playlist',
        description: 'A test playlist',
        type: 'user_created',
        isPublic: false,
        ownerId: userId,
      });
      expect(mockLogger.info).toHaveBeenCalledWith('Playlist created successfully', {
        playlistId: 'playlist-456',
        name: 'My Test Playlist',
        type: 'user_created',
        userId,
      });
    });

    it('should create a series playlist with metadata', async () => {
      // Arrange
      const seriesRequest: CreatePlaylistUseCaseRequest = {
        name: 'Attack on Titan',
        description: 'Popular anime series',
        type: 'series',
        isPublic: true,
        userId,
        metadata: {
          seriesName: 'Attack on Titan',
          genre: ['anime', 'action'],
          year: 2013,
          status: 'completed',
        },
      };

      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);
      mockPlaylistRepository.create.mockResolvedValue(Result.ok({
        ...mockPlaylist,
        ...seriesRequest,
      }));

      // Act
      const result = await useCase.execute({ ...seriesRequest, userId });

      // Assert
      expect(result.success).toBe(true);
      expect(mockPlaylistRepository.create).toHaveBeenCalledWith({
        name: 'Attack on Titan',
        description: 'Popular anime series',
        type: 'series',
        isPublic: true,
        ownerId: userId,
        metadata: {
          seriesName: 'Attack on Titan',
          genre: ['anime', 'action'],
          year: 2013,
          status: 'completed',
        },
      });
    });

    it('should create a season playlist with season metadata', async () => {
      // Arrange
      const seasonRequest: CreatePlaylistUseCaseRequest = {
        name: 'Attack on Titan Season 1',
        type: 'season',
        userId,
        metadata: {
          seriesName: 'Attack on Titan',
          seasonNumber: 1,
          episodeCount: 25,
        },
      };

      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);
      mockPlaylistRepository.create.mockResolvedValue(mockPlaylist);

      // Act
      const result = await useCase.execute({ ...seasonRequest, userId });

      // Assert
      expect(result.success).toBe(true);
    });

    it('should generate suggested metadata for series without year', async () => {
      // Arrange
      const seriesRequest: CreatePlaylistUseCaseRequest = {
        name: 'New Series',
        type: 'series',
        userId,
        metadata: {
          seriesName: 'New Series',
        },
      };

      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);
      mockPlaylistRepository.create.mockResolvedValue(mockPlaylist);

      // Act
      const result = await useCase.execute({ ...seriesRequest, userId });

      // Assert
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.suggestedMetadata).toEqual({
          status: 'ongoing',
          year: new Date().getFullYear(),
        });
      }
    });
  });

  describe('Validation errors', () => {
    it('should fail when name is empty', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, name: '' };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidPlaylistDataError);
        expect(result.error.message).toContain('name');
      }
    });

    it('should fail when name is missing', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, name: undefined as any };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(ValidationError);
        expect(result.error.message).toContain('name and type are required');
      }
    });

    it('should fail when type is missing', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, type: undefined as any };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(ValidationError);
      }
    });

    it('should fail when type is invalid', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, type: 'invalid_type' as any };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidPlaylistTypeError);
      }
    });

    it('should fail when name is too long', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, name: 'a'.repeat(256) };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidPlaylistDataError);
        expect(result.error.message).toContain('cannot exceed 255 characters');
      }
    });

    it('should fail when description is too long', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, description: 'a'.repeat(1001) };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidPlaylistDataError);
        expect(result.error.message).toContain('cannot exceed 1000 characters');
      }
    });

    it('should fail when initialVideoIds is not an array', async () => {
      // Arrange
      const invalidRequest = { ...validRequest, initialVideoIds: 'not-an-array' as any };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidPlaylistDataError);
        expect(result.error.message).toContain('must be an array');
      }
    });
  });

  describe('Metadata validation errors', () => {
    it('should fail when series playlist lacks seriesName', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);

      const invalidRequest: CreatePlaylistUseCaseRequest = {
        name: 'Test Series',
        type: 'series',
        userId,
        metadata: {
          year: 2023,
        },
      };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidSeriesMetadataError);
        expect(result.error.message).toContain('seriesName is required');
      }
    });

    it('should fail when season playlist lacks seasonNumber', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);

      const invalidRequest: CreatePlaylistUseCaseRequest = {
        name: 'Test Season',
        type: 'season',
        userId,
        metadata: {
          seriesName: 'Test Series',
        },
      };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidSeriesMetadataError);
        expect(result.error.message).toContain('seasonNumber must be a positive integer');
      }
    });

    it('should fail when seasonNumber is invalid', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);

      const invalidRequest: CreatePlaylistUseCaseRequest = {
        name: 'Test Season',
        type: 'season',
        userId,
        metadata: {
          seriesName: 'Test Series',
          seasonNumber: -1,
        },
      };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidSeriesMetadataError);
      }
    });

    it('should fail when year is invalid', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);

      const invalidRequest: CreatePlaylistUseCaseRequest = {
        name: 'Test Series',
        type: 'series',
        userId,
        metadata: {
          seriesName: 'Test Series',
          year: 1800, // Too old
        },
      };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidSeriesMetadataError);
        expect(result.error.message).toContain('year must be between');
      }
    });

    it('should fail when status is invalid', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);

      const invalidRequest: CreatePlaylistUseCaseRequest = {
        name: 'Test Series',
        type: 'series',
        userId,
        metadata: {
          seriesName: 'Test Series',
          status: 'invalid_status' as any,
        },
      };

      // Act
      const result = await useCase.execute({ ...invalidRequest, userId });

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InvalidSeriesMetadataError);
        expect(result.error.message).toContain('status must be one of');
      }
    });
  });

  describe('Business logic errors', () => {
    it('should fail when user does not exist', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(false);

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(ValidationError);
        expect(result.error.message).toContain('User not found');
      }
    });

    it('should fail when playlist name already exists for user', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(true);

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(DuplicatePlaylistNameError);
      }
      expect(mockLogger.warn).toHaveBeenCalledWith('Playlist name already exists', {
        name: 'My Test Playlist',
        userId,
      });
    });

    it('should fail when repository creation fails', async () => {
      // Arrange
      mockUserRepository.exists.mockResolvedValue(true);
      mockPlaylistRepository.nameExistsForUser.mockResolvedValue(false);
      mockPlaylistRepository.create.mockRejectedValue(
        new Error('Database error'),
      );

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InternalError);
      }
    });
  });

  describe('Error handling', () => {
    it('should handle unexpected errors gracefully', async () => {
      // Arrange
      mockUserRepository.exists.mockRejectedValue(new Error('Unexpected database error'));

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InternalError);
      }
      expect(mockLogger.error).toHaveBeenCalledWith('Unexpected error in CreatePlaylistUseCase', expect.any(Error));
    });

    it('should handle non-Error exceptions', async () => {
      // Arrange
      mockUserRepository.exists.mockRejectedValue('String error');

      // Act
      const result = await useCase.execute(validRequest);

      // Assert
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(InternalError);
        expect(result.error.message).toBe('Failed to create playlist');
      }
    });
  });
});
