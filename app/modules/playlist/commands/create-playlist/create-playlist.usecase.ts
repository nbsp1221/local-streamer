import { InternalError, ValidationError } from '~/lib/errors';
import { Result } from '~/lib/result';
import { UseCase } from '~/lib/usecase.base';
import type { CreatePlaylistRequest } from '../../domain/playlist.types';
import {
  DuplicatePlaylistNameError,
  InvalidPlaylistDataError,
  InvalidPlaylistTypeError,
  InvalidSeriesMetadataError,
} from '../../domain/playlist.errors';
import type {
  CreatePlaylistDependencies,
  CreatePlaylistUseCaseRequest,
  CreatePlaylistUseCaseResponse,
} from './create-playlist.types';

/**
 * Use case for creating new playlists
 * Handles validation, duplicate checking, and playlist creation business logic
 */
export class CreatePlaylistUseCase extends UseCase<CreatePlaylistUseCaseRequest, CreatePlaylistUseCaseResponse> {
  constructor(private readonly deps: CreatePlaylistDependencies) {
    super();
  }

  async execute(request: CreatePlaylistUseCaseRequest): Promise<Result<CreatePlaylistUseCaseResponse>> {
    const { userId, ...playlistData } = request;
    try {
      // 1. Validate input
      const validation = this.validate(request);
      if (!validation.success) {
        return validation;
      }

      // 2. Check if user exists
      const userExists = await this.deps.userRepository.exists(userId);
      if (!userExists) {
        this.deps.logger?.error('User not found for playlist creation', { userId });
        return Result.fail(new ValidationError('User not found'));
      }

      // 3. Check for duplicate playlist name
      const nameExists = await this.deps.playlistRepository.nameExistsForUser(
        playlistData.name,
        userId,
      );

      if (nameExists) {
        this.deps.logger?.warn('Playlist name already exists', { name: playlistData.name, userId });
        return Result.fail(new DuplicatePlaylistNameError(playlistData.name, userId));
      }

      // 4. Validate series metadata if provided
      if (request.metadata) {
        const metadataValidation = this.validateMetadata(request);
        if (!metadataValidation.success) {
          return metadataValidation;
        }
      }

      // 5. Create playlist through repository
      const createInput = {
        ...playlistData,
        ownerId: userId,
      };

      try {
        const playlist = await this.deps.playlistRepository.create(createInput);

        // 6. Generate suggested metadata for series types
        const suggestedMetadata = this.generateSuggestedMetadata(playlistData);

        // 7. Log successful creation
        this.deps.logger?.info('Playlist created successfully', {
          playlistId: playlist.id,
          name: playlist.name,
          type: playlist.type,
          userId,
        });

        // 8. Return success response
        return Result.ok({
          playlistId: playlist.id,
          message: `Playlist "${playlist.name}" created successfully`,
          autoGeneratedThumbnail: false, // Will be enhanced in future phases
          suggestedMetadata,
        });
      }
      catch (repositoryError) {
        this.deps.logger?.error('Failed to create playlist', repositoryError);
        return Result.fail(new InternalError('Failed to create playlist in repository'));
      }
    }
    catch (error) {
      this.deps.logger?.error('Unexpected error in CreatePlaylistUseCase', error);
      return Result.fail(
        new InternalError(
          error instanceof Error ? error.message : 'Failed to create playlist',
        ),
      );
    }
  }

  /**
   * Validate the create playlist request
   */
  private validate(request: CreatePlaylistUseCaseRequest): Result<void> {
    // Check required fields
    if (request.name === undefined || request.name === null || !request.type) {
      return Result.fail(new ValidationError('Playlist name and type are required'));
    }

    // Validate name
    if (request.name.trim().length === 0) {
      return Result.fail(new InvalidPlaylistDataError('name', 'cannot be empty'));
    }

    if (request.name.trim().length > 255) {
      return Result.fail(new InvalidPlaylistDataError('name', 'cannot exceed 255 characters'));
    }

    // Validate description
    if (request.description && request.description.trim().length > 1000) {
      return Result.fail(new InvalidPlaylistDataError('description', 'cannot exceed 1000 characters'));
    }

    // Validate type
    const validTypes = ['user_created', 'series', 'season', 'auto_generated'];
    if (!validTypes.includes(request.type)) {
      return Result.fail(new InvalidPlaylistTypeError(request.type));
    }

    // Validate initial video IDs array
    if (request.initialVideoIds && !Array.isArray(request.initialVideoIds)) {
      return Result.fail(new InvalidPlaylistDataError('initialVideoIds', 'must be an array'));
    }

    return Result.ok(undefined);
  }

  /**
   * Validate metadata for series and season playlists
   */
  private validateMetadata(request: CreatePlaylistUseCaseRequest): Result<void> {
    const metadata = request.metadata!;

    // Series name validation for series/season types
    if ((request.type === 'series' || request.type === 'season') && !metadata.seriesName) {
      return Result.fail(new InvalidSeriesMetadataError('seriesName is required for series and season playlists'));
    }

    // Season number validation for season type
    if (request.type === 'season') {
      if (!metadata.seasonNumber || metadata.seasonNumber < 1) {
        return Result.fail(new InvalidSeriesMetadataError('seasonNumber must be a positive integer for season playlists'));
      }
    }

    // Episode count validation
    if (metadata.episodeCount !== undefined && metadata.episodeCount < 0) {
      return Result.fail(new InvalidSeriesMetadataError('episodeCount must be a non-negative integer'));
    }

    // Year validation
    if (metadata.year !== undefined) {
      const currentYear = new Date().getFullYear();
      if (metadata.year < 1900 || metadata.year > currentYear + 10) {
        return Result.fail(new InvalidSeriesMetadataError(`year must be between 1900 and ${currentYear + 10}`));
      }
    }

    // Genre validation
    if (metadata.genre && !Array.isArray(metadata.genre)) {
      return Result.fail(new InvalidSeriesMetadataError('genre must be an array of strings'));
    }

    // Status validation
    if (metadata.status && !['ongoing', 'completed', 'hiatus'].includes(metadata.status)) {
      return Result.fail(new InvalidSeriesMetadataError('status must be one of: ongoing, completed, hiatus'));
    }

    return Result.ok(undefined);
  }

  /**
   * Generate suggested metadata based on playlist type and input
   */
  private generateSuggestedMetadata(request: CreatePlaylistRequest): Partial<CreatePlaylistRequest['metadata']> | undefined {
    if (request.type === 'user_created') {
      return undefined; // No suggestions for user-created playlists
    }

    const suggestions: Partial<CreatePlaylistRequest['metadata']> = {};

    // Auto-suggest status for series
    if (request.type === 'series' && !request.metadata?.status) {
      suggestions.status = 'ongoing';
    }

    // Auto-suggest current year if not provided
    if (!request.metadata?.year) {
      suggestions.year = new Date().getFullYear();
    }

    // Return suggestions only if we have any
    return Object.keys(suggestions).length > 0 ? suggestions : undefined;
  }
}
